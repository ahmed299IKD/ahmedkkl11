import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import yfinance as yf
from datetime import datetime, timedelta
import io
import warnings
import requests
import json
from typing import Dict, List, Optional, Tuple
import pickle
import base64
from pathlib import Path
import time
import threading
from dataclasses import dataclass
from enum import Enum
import hashlib
import hmac
import os

# Advanced ML/AI imports
import tensorflow as tf
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import LSTM, Dense, Dropout, Attention
from tensorflow.keras.optimizers import Adam
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import ta
from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification
import torch
from scipy import stats
from scipy.optimize import minimize
import networkx as nx

# Suppress warnings
warnings.filterwarnings('ignore')

# Configuration constants
class Config:
    SUPPORTED_APIS = {
        'Yahoo Finance': 'yfinance',
        'Alpha Vantage': 'alpha_vantage',
        'Finnhub': 'finnhub',
        'Polygon': 'polygon',
        'MarketStack': 'marketstack'
    }
    
    AI_MODELS = {
        'LSTM': 'lstm',
        'Transformer': 'transformer',
        'XGBoost': 'xgboost',
        'Random Forest': 'random_forest',
        'Prophet': 'prophet'
    }
    
    TECHNICAL_INDICATORS = [
        'RSI', 'MACD', 'Bollinger Bands', 'Stochastic', 'ADX',
        'CCI', 'Williams %R', 'MFI', 'OBV', 'ATR'
    ]
    
    SENTIMENT_MODELS = {
        'FinBERT': 'ProsusAI/finbert',
        'RoBERTa': 'cardiffnlp/twitter-roberta-base-sentiment-latest',
        'FinBERT-Tone': 'yiyanghkust/finbert-tone'
    }

# Data classes for better structure
@dataclass
class AssetData:
    symbol: str
    name: str
    data: pd.DataFrame
    metadata: Dict = None

@dataclass
class AIModel:
    name: str
    model: object
    scaler: object
    performance_metrics: Dict
    training_date: datetime

@dataclass
class TradingSignal:
    timestamp: datetime
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    confidence: float
    price: float
    indicators: Dict

# Initialize session state
def init_session_state():
    if 'assets' not in st.session_state:
        st.session_state.assets = {}
    if 'ai_models' not in st.session_state:
        st.session_state.ai_models = {}
    if 'trading_signals' not in st.session_state:
        st.session_state.trading_signals = []
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []
    if 'user_preferences' not in st.session_state:
        st.session_state.user_preferences = {
            'theme': 'professional',
            'risk_tolerance': 'moderate',
            'default_indicators': ['RSI', 'MACD', 'Bollinger Bands']
        }

# Advanced page configuration
st.set_page_config(
    layout="wide",
    page_title="Enhanced ETF Analytics Platform V6.0 - AI-Powered Financial Intelligence",
    page_icon="üöÄ",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://docs.streamlit.io',
        'Report a bug': "https://github.com/streamlit/streamlit/issues",
        'About': "# Enhanced ETF Analytics Platform V6.0\n\nAdvanced AI-powered financial analytics platform."
    }
)

# Initialize session state
init_session_state()

# Advanced CSS with animations and modern design
st.markdown("""
<style>
    :root {
        --primary-color: #667eea;
        --secondary-color: #764ba2;
        --success-color: #48bb78;
        --danger-color: #f56565;
        --warning-color: #ed8936;
        --info-color: #4299e1;
    }
    
    .main-header {
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
        padding: 2rem;
        border-radius: 15px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        animation: slideInDown 0.8s ease-out;
    }
    
    .metric-card {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        padding: 1.5rem;
        border-radius: 12px;
        border-left: 5px solid var(--primary-color);
        margin: 0.5rem 0;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .metric-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    }
    
    .feature-highlight {
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 12px;
        margin: 1rem 0;
        box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        animation: fadeIn 1s ease-out;
    }
    
    .ai-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 12px;
        margin: 1rem 0;
        border: 2px solid rgba(255,255,255,0.2);
    }
    
    .trading-signal {
        padding: 1rem;
        border-radius: 8px;
        margin: 0.5rem 0;
        border-left: 4px solid;
    }
    
    .signal-buy { border-left-color: var(--success-color); background: rgba(72, 187, 120, 0.1); }
    .signal-sell { border-left-color: var(--danger-color); background: rgba(245, 101, 101, 0.1); }
    .signal-hold { border-left-color: var(--warning-color); background: rgba(237, 137, 54, 0.1); }
    
    .stTabs [data-baseweb="tab-list"] {
        gap: 2px;
        background: rgba(0,0,0,0.05);
        border-radius: 8px;
        padding: 5px;
    }
    
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        padding-left: 20px;
        padding-right: 20px;
        border-radius: 6px;
        transition: all 0.3s ease;
    }
    
    .stTabs [data-baseweb="tab"]:hover {
        background: rgba(102, 126, 234, 0.1);
    }
    
    .chat-container {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        background: #f8f9fa;
    }
    
    .chat-message {
        margin: 0.5rem 0;
        padding: 0.75rem;
        border-radius: 8px;
        max-width: 80%;
    }
    
    .user-message {
        background: var(--primary-color);
        color: white;
        margin-left: auto;
    }
    
    .ai-message {
        background: #e2e8f0;
        color: #2d3748;
    }
    
    @keyframes slideInDown {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255,255,255,.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .progress-bar {
        width: 100%;
        height: 4px;
        background: #e2e8f0;
        border-radius: 2px;
        overflow: hidden;
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
        border-radius: 2px;
        transition: width 0.3s ease;
    }
</style>
""", unsafe_allow_html=True)

# Enhanced header with real-time updates
st.markdown("""
<div class="main-header">
    <h1>üöÄ Enhanced ETF Analytics Platform V6.0</h1>
    <p>Advanced AI-Powered Financial Intelligence Platform</p>
    <div style="margin-top: 1rem;">
        <span style="background: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px; margin: 0 0.5rem;">
            ü§ñ AI Models: LSTM, Transformers, XGBoost
        </span>
        <span style="background: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px; margin: 0 0.5rem;">
            üìä Real-time Data: Multiple APIs
        </span>
        <span style="background: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px; margin: 0 0.5rem;">
            üß† Sentiment Analysis: FinBERT, RoBERTa
        </span>
    </div>
</div>
""", unsafe_allow_html=True)

# Advanced data loading functions with caching
@st.cache_data(ttl=300, show_spinner=False)
def load_yahoo_data(symbol: str, period: str = "1y") -> pd.DataFrame:
    """Load data from Yahoo Finance with caching."""
    try:
        ticker = yf.Ticker(symbol)
        data = ticker.history(period=period)
        if data.empty:
            return None
        data.reset_index(inplace=True)
        data.columns = [col.lower().replace(' ', '_') for col in data.columns]
        return data
    except Exception as e:
        st.error(f"Error loading Yahoo Finance data: {e}")
        return None

@st.cache_data(ttl=300, show_spinner=False)
def load_alpha_vantage_data(symbol: str, api_key: str) -> pd.DataFrame:
    """Load data from Alpha Vantage API."""
    try:
        url = f"https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol={symbol}&apikey={api_key}&outputsize=full"
        response = requests.get(url)
        data = response.json()
        
        if "Time Series (Daily)" not in data:
            return None
            
        df = pd.DataFrame(data["Time Series (Daily)"]).T
        df.index = pd.to_datetime(df.index)
        df.columns = [col.split('. ')[1].lower() for col in df.columns]
        df.reset_index(inplace=True)
        df.rename(columns={'index': 'date'}, inplace=True)
        df = df.sort_values('date')
        return df
    except Exception as e:
        st.error(f"Error loading Alpha Vantage data: {e}")
        return None

@st.cache_data(ttl=300, show_spinner=False)
def load_finnhub_data(symbol: str, api_key: str) -> pd.DataFrame:
    """Load data from Finnhub API."""
    try:
        end_date = datetime.now()
        start_date = end_date - timedelta(days=365)
        
        url = f"https://finnhub.io/api/v1/stock/candle?symbol={symbol}&resolution=D&from={int(start_date.timestamp())}&to={int(end_date.timestamp())}&token={api_key}"
        response = requests.get(url)
        data = response.json()
        
        if data['s'] != 'ok':
            return None
            
        df = pd.DataFrame({
            'date': pd.to_datetime(data['t'], unit='s'),
            'open': data['o'],
            'high': data['h'],
            'low': data['l'],
            'close': data['c'],
            'volume': data['v']
        })
        return df
    except Exception as e:
        st.error(f"Error loading Finnhub data: {e}")
        return None

# Advanced AI model training functions
@st.cache_resource(show_spinner=False)
def create_lstm_model(input_shape: int) -> Sequential:
    """Create LSTM model for time series forecasting."""
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=input_shape),
        Dropout(0.2),
        LSTM(50, return_sequences=True),
        Dropout(0.2),
        LSTM(50),
        Dropout(0.2),
        Dense(25),
        Dense(1)
    ])
    model.compile(optimizer=Adam(learning_rate=0.001), loss='mse')
    return model

@st.cache_resource(show_spinner=False)
def load_sentiment_model(model_name: str = "ProsusAI/finbert"):
    """Load pre-trained sentiment analysis model."""
    try:
        tokenizer = AutoTokenizer.from_pretrained(model_name)
        model = AutoModelForSequenceClassification.from_pretrained(model_name)
        return tokenizer, model
    except Exception as e:
        st.error(f"Error loading sentiment model: {e}")
        return None, None

# Technical analysis functions
def calculate_technical_indicators(data: pd.DataFrame) -> pd.DataFrame:
    """Calculate various technical indicators."""
    df = data.copy()
    
    # RSI
    df['rsi'] = ta.momentum.RSIIndicator(df['close']).rsi()
    
    # MACD
    macd = ta.trend.MACD(df['close'])
    df['macd'] = macd.macd()
    df['macd_signal'] = macd.macd_signal()
    df['macd_histogram'] = macd.macd_diff()
    
    # Bollinger Bands
    bb = ta.volatility.BollingerBands(df['close'])
    df['bb_upper'] = bb.bollinger_hband()
    df['bb_middle'] = bb.bollinger_mavg()
    df['bb_lower'] = bb.bollinger_lband()
    
    # Stochastic
    stoch = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close'])
    df['stoch_k'] = stoch.stoch()
    df['stoch_d'] = stoch.stoch_signal()
    
    # ADX
    df['adx'] = ta.trend.ADXIndicator(df['high'], df['low'], df['close']).adx()
    
    # CCI
    df['cci'] = ta.trend.CCIIndicator(df['high'], df['low'], df['close']).cci()
    
    # Williams %R
    df['williams_r'] = ta.momentum.WilliamsRIndicator(df['high'], df['low'], df['close']).williams_r()
    
    # MFI
    df['mfi'] = ta.volume.MFIIndicator(df['high'], df['low'], df['close'], df['volume']).money_flow_index()
    
    # OBV
    df['obv'] = ta.volume.OnBalanceVolumeIndicator(df['close'], df['volume']).on_balance_volume()
    
    # ATR
    df['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()
    
    return df

# Advanced sentiment analysis
def analyze_financial_sentiment(text: str, tokenizer, model) -> Dict:
    """Analyze sentiment of financial text using FinBERT."""
    if tokenizer is None or model is None:
        return {'sentiment': 'neutral', 'confidence': 0.5}
    
    try:
        inputs = tokenizer(text, return_tensors="pt", truncation=True, max_length=512)
        outputs = model(**inputs)
        predictions = torch.nn.functional.softmax(outputs.logits, dim=-1)
        sentiment_idx = torch.argmax(predictions).item()
        confidence = predictions[0][sentiment_idx].item()
        
        sentiment_map = {0: 'negative', 1: 'neutral', 2: 'positive'}
        return {
            'sentiment': sentiment_map[sentiment_idx],
            'confidence': confidence,
            'probabilities': {
                'negative': predictions[0][0].item(),
                'neutral': predictions[0][1].item(),
                'positive': predictions[0][2].item()
            }
        }
    except Exception as e:
        st.error(f"Error in sentiment analysis: {e}")
        return {'sentiment': 'neutral', 'confidence': 0.5}

# Trading signal generation
def generate_trading_signals(data: pd.DataFrame, model_type: str = 'ensemble') -> List[TradingSignal]:
    """Generate trading signals using AI models."""
    signals = []
    
    # Calculate technical indicators
    df = calculate_technical_indicators(data)
    
    for i in range(1, len(df)):
        signal_type = 'HOLD'
        confidence = 0.5
        
        # Simple rule-based signals (can be enhanced with ML models)
        if df['rsi'].iloc[i] < 30 and df['macd'].iloc[i] > df['macd_signal'].iloc[i]:
            signal_type = 'BUY'
            confidence = 0.7
        elif df['rsi'].iloc[i] > 70 and df['macd'].iloc[i] < df['macd_signal'].iloc[i]:
            signal_type = 'SELL'
            confidence = 0.7
        
        # Create trading signal
        signal = TradingSignal(
            timestamp=df['date'].iloc[i],
            symbol=data.get('symbol', 'UNKNOWN'),
            signal_type=signal_type,
            confidence=confidence,
            price=df['close'].iloc[i],
            indicators={
                'rsi': df['rsi'].iloc[i],
                'macd': df['macd'].iloc[i],
                'bb_position': (df['close'].iloc[i] - df['bb_lower'].iloc[i]) / (df['bb_upper'].iloc[i] - df['bb_lower'].iloc[i])
            }
        )
        signals.append(signal)
    
    return signals

# Advanced visualization functions
def create_candlestick_chart(data: pd.DataFrame, indicators: List[str] = None) -> go.Figure:
    """Create advanced candlestick chart with technical indicators."""
    fig = make_subplots(
        rows=3, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        subplot_titles=('Price', 'Volume', 'Indicators'),
        row_heights=[0.6, 0.2, 0.2]
    )
    
    # Candlestick chart
    fig.add_trace(go.Candlestick(
        x=data['date'],
        open=data['open'],
        high=data['high'],
        low=data['low'],
        close=data['close'],
        name='Price'
    ), row=1, col=1)
    
    # Volume
    fig.add_trace(go.Bar(
        x=data['date'],
        y=data['volume'],
        name='Volume',
        marker_color='rgba(102, 126, 234, 0.6)'
    ), row=2, col=1)
    
    # Technical indicators
    if indicators:
        df = calculate_technical_indicators(data)
        
        if 'RSI' in indicators and 'rsi' in df.columns:
            fig.add_trace(go.Scatter(
                x=df['date'],
                y=df['rsi'],
                name='RSI',
                line=dict(color='orange')
            ), row=3, col=1)
        
        if 'MACD' in indicators and 'macd' in df.columns:
            fig.add_trace(go.Scatter(
                x=df['date'],
                y=df['macd'],
                name='MACD',
                line=dict(color='blue')
            ), row=3, col=1)
            fig.add_trace(go.Scatter(
                x=df['date'],
                y=df['macd_signal'],
                name='MACD Signal',
                line=dict(color='red')
            ), row=3, col=1)
    
    fig.update_layout(
        height=800,
        title='Advanced Candlestick Chart with Technical Indicators',
        xaxis_title='Date',
        yaxis_title='Price',
        template='plotly_dark'
    )
    
    return fig

def create_correlation_heatmap(data: Dict[str, pd.DataFrame]) -> go.Figure:
    """Create correlation heatmap for multiple assets."""
    # Extract close prices for all assets
    close_prices = {}
    for symbol, df in data.items():
        if 'close' in df.columns:
            close_prices[symbol] = df['close']
    
    if len(close_prices) < 2:
        return None
    
    # Create correlation matrix
    corr_df = pd.DataFrame(close_prices).corr()
    
    fig = go.Figure(data=go.Heatmap(
        z=corr_df.values,
        x=corr_df.columns,
        y=corr_df.columns,
        colorscale='RdBu',
        zmid=0,
        text=corr_df.values,
        texttemplate="%{text:.2f}",
        textfont={"size": 10},
        hoverongaps=False
    ))
    
    fig.update_layout(
        title='Asset Correlation Heatmap',
        width=600,
        height=600
    )
    
    return fig

# AI Chat Interface
def ai_chat_interface():
    """Advanced AI chat interface for financial analysis."""
    st.subheader("ü§ñ AI Financial Analyst Chat")
    
    # Chat container
    chat_container = st.container()
    
    with chat_container:
        # Display chat history
        for message in st.session_state.chat_history:
            if message['role'] == 'user':
                st.markdown(f"""
                <div class="chat-message user-message">
                    <strong>You:</strong> {message['content']}
                </div>
                """, unsafe_allow_html=True)
            else:
                st.markdown(f"""
                <div class="chat-message ai-message">
                    <strong>AI Analyst:</strong> {message['content']}
                </div>
                """, unsafe_allow_html=True)
    
    # Chat input
    user_input = st.chat_input("Ask about financial analysis, trading strategies, or market insights...")
    
    if user_input:
        # Add user message to chat history
        st.session_state.chat_history.append({'role': 'user', 'content': user_input})
        
        # Generate AI response (simulated)
        with st.spinner("AI Analyst is thinking..."):
            time.sleep(1)  # Simulate processing time
            
            # Simple response generation (can be enhanced with actual AI models)
            if "sentiment" in user_input.lower():
                response = "Based on current market analysis, the sentiment appears cautiously optimistic. Recent news and technical indicators suggest a neutral to positive outlook for most sectors."
            elif "prediction" in user_input.lower():
                response = "My AI models predict a potential upward trend in the coming weeks, with a 65% confidence level. However, market volatility remains a key risk factor."
            elif "strategy" in user_input.lower():
                response = "I recommend a diversified approach with focus on value stocks and defensive sectors. Current technical indicators suggest a balanced portfolio with 60% equities and 40% fixed income."
            else:
                response = f"I understand you're asking about '{user_input}'. Let me analyze the current market data and provide you with detailed insights. Based on the latest data, I suggest monitoring key technical indicators and market sentiment for optimal decision-making."
        
        # Add AI response to chat history
        st.session_state.chat_history.append({'role': 'assistant', 'content': response})
        
        # Rerun to update the chat interface
        st.rerun()

# Enhanced sidebar with advanced features
def enhanced_sidebar():
    """Enhanced sidebar with advanced configuration options."""
    st.sidebar.markdown("## ‚öôÔ∏è Advanced Configuration")
    
    # Data source selection
    st.sidebar.markdown("### üìä Data Sources")
    data_source = st.sidebar.selectbox(
        "Choose your data source:",
        ["Yahoo Finance", "Alpha Vantage", "Finnhub", "Polygon", "MarketStack", "Upload CSV"]
    )
    
    # API key input for selected services
    if data_source in ["Alpha Vantage", "Finnhub", "Polygon", "MarketStack"]:
        api_key = st.sidebar.text_input(f"{data_source} API Key:", type="password")
    
    # Multi-asset selection
    st.sidebar.markdown("### üìà Asset Selection")
    assets_input = st.sidebar.text_area(
        "Enter symbols (comma-separated):",
        "SPY, QQQ, IWM, GLD, TLT"
    )
    
    # Date range selection
    st.sidebar.markdown("### üìÖ Date Range")
    col1, col2 = st.sidebar.columns(2)
    with col1:
        start_date = st.sidebar.date_input("Start Date", datetime.now() - timedelta(days=365))
    with col2:
        end_date = st.sidebar.date_input("End Date", datetime.now())
    
    # AI Model Configuration
    st.sidebar.markdown("### ü§ñ AI Model Settings")
    model_type = st.sidebar.selectbox(
        "Primary AI Model:",
        ["LSTM", "Transformer", "XGBoost", "Random Forest", "Ensemble"]
    )
    
    # Technical indicators selection
    st.sidebar.markdown("### üìä Technical Indicators")
    selected_indicators = st.sidebar.multiselect(
        "Select indicators:",
        Config.TECHNICAL_INDICATORS,
        default=['RSI', 'MACD', 'Bollinger Bands']
    )
    
    # Risk management settings
    st.sidebar.markdown("### ‚ö†Ô∏è Risk Management")
    risk_tolerance = st.sidebar.selectbox(
        "Risk Tolerance:",
        ["Conservative", "Moderate", "Aggressive"]
    )
    
    max_position_size = st.sidebar.slider(
        "Max Position Size (%)",
        1, 20, 5
    )
    
    stop_loss = st.sidebar.slider(
        "Stop Loss (%)",
        1, 10, 3
    )
    
    # Real-time settings
    st.sidebar.markdown("### ‚ö° Real-time Settings")
    auto_refresh = st.sidebar.checkbox("Auto-refresh data")
    if auto_refresh:
        refresh_interval = st.sidebar.selectbox(
            "Refresh interval:",
            ["1 min", "5 min", "15 min", "30 min", "1 hour"]
        )
    
    # Load data button
    if st.sidebar.button("üöÄ Load Data", type="primary"):
        load_data(data_source, assets_input, start_date, end_date)
    
    return {
        'data_source': data_source,
        'assets_input': assets_input,
        'start_date': start_date,
        'end_date': end_date,
        'model_type': model_type,
        'selected_indicators': selected_indicators,
        'risk_tolerance': risk_tolerance,
        'max_position_size': max_position_size,
        'stop_loss': stop_loss,
        'auto_refresh': auto_refresh
    }

# Data loading function
def load_data(data_source: str, assets_input: str, start_date: datetime, end_date: datetime):
    """Load data based on selected source and assets."""
    assets = [asset.strip().upper() for asset in assets_input.split(',')]
    
    with st.spinner(f"Loading data from {data_source}..."):
        progress_bar = st.progress(0)
        
        for i, asset in enumerate(assets):
            try:
                if data_source == "Yahoo Finance":
                    data = load_yahoo_data(asset)
                elif data_source == "Alpha Vantage":
                    # Note: You would need to pass API key here
                    data = load_yahoo_data(asset)  # Fallback to Yahoo for demo
                else:
                    data = load_yahoo_data(asset)  # Fallback to Yahoo for demo
                
                if data is not None:
                    st.session_state.assets[asset] = AssetData(
                        symbol=asset,
                        name=asset,
                        data=data
                    )
                
                progress_bar.progress((i + 1) / len(assets))
                
            except Exception as e:
                st.error(f"Error loading {asset}: {e}")
        
        progress_bar.empty()
        
        if st.session_state.assets:
            st.success(f"‚úÖ Successfully loaded {len(st.session_state.assets)} assets")
        else:
            st.error("‚ùå No assets loaded successfully")

# Main application tabs
def main_application():
    """Main application with enhanced tabs."""
    if not st.session_state.assets:
        st.warning("‚ö†Ô∏è Please load data first using the sidebar configuration.")
        return
    
    tabs = st.tabs([
        "üìä Dashboard", 
        "üß† AI Analysis", 
        "üìà Predictions", 
        "‚ö° Trading Signals", 
        "üîç Advanced Analytics", 
        "üìã Reports", 
        "üí¨ AI Chat",
        "‚öôÔ∏è Settings"
    ])
    
    # Dashboard Tab
    with tabs[0]:
        dashboard_tab()
    
    # AI Analysis Tab
    with tabs[1]:
        ai_analysis_tab()
    
    # Predictions Tab
    with tabs[2]:
        predictions_tab()
    
    # Trading Signals Tab
    with tabs[3]:
        trading_signals_tab()
    
    # Advanced Analytics Tab
    with tabs[4]:
        advanced_analytics_tab()
    
    # Reports Tab
    with tabs[5]:
        reports_tab()
    
    # AI Chat Tab
    with tabs[6]:
        ai_chat_interface()
    
    # Settings Tab
    with tabs[7]:
        settings_tab()

def dashboard_tab():
    """Enhanced dashboard with real-time metrics."""
    st.header("üìä Advanced Dashboard")
    
    # Get the first asset for display
    first_asset = list(st.session_state.assets.values())[0]
    data = first_asset.data
    
    # Key metrics
    col1, col2, col3, col4, col5, col6 = st.columns(6)
    
    with col1:
        current_price = data['close'].iloc[-1]
        st.markdown(f"""
        <div class="metric-card">
            <h4>üí∞ Current Price</h4>
            <h2>${current_price:.2f}</h2>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        daily_change = ((data['close'].iloc[-1] / data['close'].iloc[-2]) - 1) * 100
        color = "green" if daily_change > 0 else "red"
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìä Daily Change</h4>
            <h2 style="color: {color}">{daily_change:+.2f}%</h2>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        volatility = data['close'].pct_change().std() * np.sqrt(252) * 100
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìâ Annual Volatility</h4>
            <h2>{volatility:.2f}%</h2>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        if 'volume' in data.columns:
            avg_volume = data['volume'].mean()
            st.markdown(f"""
            <div class="metric-card">
                <h4>üìä Avg Volume</h4>
                <h2>{avg_volume/1000000:.1f}M</h2>
            </div>
            """, unsafe_allow_html=True)
    
    with col5:
        rsi = ta.momentum.RSIIndicator(data['close']).rsi().iloc[-1]
        rsi_color = "red" if rsi > 70 else "green" if rsi < 30 else "orange"
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìà RSI</h4>
            <h2 style="color: {rsi_color}">{rsi:.1f}</h2>
        </div>
        """, unsafe_allow_html=True)
    
    with col6:
        # Calculate MACD
        macd = ta.trend.MACD(data['close'])
        macd_signal = macd.macd_signal().iloc[-1]
        macd_value = macd.macd().iloc[-1]
        macd_color = "green" if macd_value > macd_signal else "red"
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìä MACD</h4>
            <h2 style="color: {macd_color}">{macd_value:.3f}</h2>
        </div>
        """, unsafe_allow_html=True)
    
    # Advanced charts
    st.subheader("üìà Advanced Technical Analysis")
    
    # Candlestick chart with indicators
    fig = create_candlestick_chart(data, ['RSI', 'MACD'])
    st.plotly_chart(fig, use_container_width=True)
    
    # Correlation heatmap
    if len(st.session_state.assets) > 1:
        st.subheader("üîó Asset Correlation Matrix")
        corr_fig = create_correlation_heatmap({k: v.data for k, v in st.session_state.assets.items()})
        if corr_fig:
            st.plotly_chart(corr_fig, use_container_width=True)

def ai_analysis_tab():
    """Advanced AI analysis with multiple models."""
    st.header("üß† Advanced AI Analysis")
    
    # Model selection
    col1, col2 = st.columns(2)
    with col1:
        analysis_type = st.selectbox(
            "Analysis Type:",
            ["Sentiment Analysis", "Anomaly Detection", "Pattern Recognition", "Risk Assessment"]
        )
    with col2:
        model_selection = st.selectbox(
            "AI Model:",
            ["FinBERT", "RoBERTa", "Ensemble", "Custom Model"]
        )
    
    if analysis_type == "Sentiment Analysis":
        sentiment_analysis_section()
    elif analysis_type == "Anomaly Detection":
        anomaly_detection_section()
    elif analysis_type == "Pattern Recognition":
        pattern_recognition_section()
    elif analysis_type == "Risk Assessment":
        risk_assessment_section()

def sentiment_analysis_section():
    """Advanced sentiment analysis with multiple models."""
    st.subheader("üí≠ Advanced Sentiment Analysis")
    
    # Load sentiment models
    tokenizer, model = load_sentiment_model()
    
    # Text input for analysis
    text_input = st.text_area(
        "Enter financial text for sentiment analysis:",
        "The market showed strong performance today with tech stocks leading the gains. Investors are optimistic about the upcoming earnings season."
    )
    
    if st.button("üîç Analyze Sentiment"):
        if text_input.strip():
            with st.spinner("Analyzing sentiment..."):
                result = analyze_financial_sentiment(text_input, tokenizer, model)
                
                # Display results
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    sentiment_color = {
                        'positive': '#48bb78',
                        'negative': '#f56565',
                        'neutral': '#ed8936'
                    }
                    st.markdown(f"""
                    <div class="metric-card">
                        <h4>üìä Sentiment</h4>
                        <h2 style="color: {sentiment_color[result['sentiment']]}">{result['sentiment'].upper()}</h2>
                    </div>
                    """, unsafe_allow_html=True)
                
                with col2:
                    st.markdown(f"""
                    <div class="metric-card">
                        <h4>üéØ Confidence</h4>
                        <h2>{result['confidence']:.2%}</h2>
                    </div>
                    """, unsafe_allow_html=True)
                
                with col3:
                    # Determine recommendation
                    if result['sentiment'] == 'positive' and result['confidence'] > 0.7:
                        recommendation = "BUY"
                        rec_color = "#48bb78"
                    elif result['sentiment'] == 'negative' and result['confidence'] > 0.7:
                        recommendation = "SELL"
                        rec_color = "#f56565"
                    else:
                        recommendation = "HOLD"
                        rec_color = "#ed8936"
                    
                    st.markdown(f"""
                    <div class="metric-card">
                        <h4>üí° Recommendation</h4>
                        <h2 style="color: {rec_color}">{recommendation}</h2>
                    </div>
                    """, unsafe_allow_html=True)
                
                # Probability distribution
                st.subheader("üìà Sentiment Probability Distribution")
                prob_df = pd.DataFrame(list(result['probabilities'].items()), columns=['Sentiment', 'Probability'])
                fig = px.bar(prob_df, x='Sentiment', y='Probability', color='Sentiment')
                st.plotly_chart(fig, use_container_width=True)
        else:
            st.warning("‚ö†Ô∏è Please enter text for analysis")

def anomaly_detection_section():
    """Advanced anomaly detection using multiple algorithms."""
    st.subheader("üîç Advanced Anomaly Detection")
    
    # Algorithm selection
    algorithm = st.selectbox(
        "Detection Algorithm:",
        ["Isolation Forest", "One-Class SVM", "Autoencoder", "Local Outlier Factor", "Ensemble"]
    )
    
    # Get data
    first_asset = list(st.session_state.assets.values())[0]
    data = first_asset.data
    
    if st.button("üîç Detect Anomalies"):
        with st.spinner(f"Detecting anomalies using {algorithm}..."):
            # Simulate anomaly detection
            np.random.seed(42)
            anomaly_indices = np.random.choice(len(data), size=int(len(data) * 0.05), replace=False)
            
            # Create anomaly column
            data_with_anomalies = data.copy()
            data_with_anomalies['anomaly'] = False
            data_with_anomalies.loc[anomaly_indices, 'anomaly'] = True
            
            # Create visualization
            fig = go.Figure()
            
            # Normal data
            normal_data = data_with_anomalies[~data_with_anomalies['anomaly']]
            fig.add_trace(go.Scatter(
                x=normal_data['date'],
                y=normal_data['close'],
                mode='lines',
                name='Normal Price',
                line=dict(color='blue')
            ))
            
            # Anomalies
            anomaly_data = data_with_anomalies[data_with_anomalies['anomaly']]
            fig.add_trace(go.Scatter(
                x=anomaly_data['date'],
                y=anomaly_data['close'],
                mode='markers',
                name='Anomalies',
                marker=dict(color='red', size=10, symbol='x')
            ))
            
            fig.update_layout(
                title=f"Anomaly Detection - {algorithm}",
                xaxis_title="Date",
                yaxis_title="Price",
                height=500
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Statistics
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Anomalies Detected", len(anomaly_indices))
            with col2:
                st.metric("Detection Rate", f"{len(anomaly_indices)/len(data)*100:.2f}%")
            with col3:
                st.metric("Confidence Score", f"{np.random.uniform(0.8, 0.95):.3f}")

def pattern_recognition_section():
    """Advanced pattern recognition for trading."""
    st.subheader("üîÆ Advanced Pattern Recognition")
    
    # Pattern type selection
    pattern_type = st.selectbox(
        "Pattern Type:",
        ["Candlestick Patterns", "Chart Patterns", "Harmonic Patterns", "Wave Patterns"]
    )
    
    if pattern_type == "Candlestick Patterns":
        st.info("üîç Analyzing candlestick patterns...")
        
        # Simulate pattern detection
        patterns = {
            'Doji': 12,
            'Hammer': 8,
            'Engulfing': 15,
            'Morning Star': 5,
            'Evening Star': 3
        }
        
        # Display pattern statistics
        col1, col2 = st.columns(2)
        with col1:
            st.subheader("üìä Detected Patterns")
            pattern_df = pd.DataFrame(list(patterns.items()), columns=['Pattern', 'Count'])
            fig = px.bar(pattern_df, x='Pattern', y='Count', color='Pattern')
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            st.subheader("üìà Pattern Performance")
            performance_data = {
                'Pattern': list(patterns.keys()),
                'Success Rate': [65, 72, 58, 81, 76],
                'Avg Return': [2.1, 3.2, 1.8, 4.5, 3.8]
            }
            perf_df = pd.DataFrame(performance_data)
            fig = px.scatter(perf_df, x='Success Rate', y='Avg Return', color='Pattern', size='Count')
            st.plotly_chart(fig, use_container_width=True)

def risk_assessment_section():
    """Advanced risk assessment and management."""
    st.subheader("‚ö†Ô∏è Advanced Risk Assessment")
    
    # Get data
    first_asset = list(st.session_state.assets.values())[0]
    data = first_asset.data
    
    # Calculate risk metrics
    returns = data['close'].pct_change().dropna()
    
    # Value at Risk (VaR)
    var_95 = returns.quantile(0.05)
    var_99 = returns.quantile(0.01)
    
    # Expected Shortfall (CVaR)
    cvar_95 = returns[returns <= var_95].mean()
    cvar_99 = returns[returns <= var_99].mean()
    
    # Maximum Drawdown
    cumulative_returns = (1 + returns).cumprod()
    running_max = cumulative_returns.expanding().max()
    drawdown = (cumulative_returns - running_max) / running_max
    max_drawdown = drawdown.min()
    
    # Display risk metrics
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìä VaR (95%)</h4>
            <h2>{var_95:.2%}</h2>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìä CVaR (95%)</h4>
            <h2>{cvar_95:.2%}</h2>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìâ Max Drawdown</h4>
            <h2>{max_drawdown:.2%}</h2>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        sharpe_ratio = returns.mean() / returns.std() * np.sqrt(252)
        st.markdown(f"""
        <div class="metric-card">
            <h4>üìà Sharpe Ratio</h4>
            <h2>{sharpe_ratio:.2f}</h2>
        </div>
        """, unsafe_allow_html=True)
    
    # Drawdown chart
    st.subheader("üìâ Drawdown Analysis")
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=data['date'],
        y=drawdown * 100,
        mode='lines',
        name='Drawdown',
        fill='tonexty',
        line=dict(color='red')
    ))
    fig.update_layout(
        title="Portfolio Drawdown Over Time",
        xaxis_title="Date",
        yaxis_title="Drawdown (%)",
        height=400
    )
    st.plotly_chart(fig, use_container_width=True)

def predictions_tab():
    """Advanced predictions with multiple AI models."""
    st.header("üìà Advanced AI Predictions")
    
    # Model configuration
    col1, col2, col3 = st.columns(3)
    with col1:
        model_type = st.selectbox(
            "Prediction Model:",
            ["LSTM", "Transformer", "XGBoost", "Prophet", "Ensemble"]
        )
    with col2:
        forecast_days = st.slider("Forecast Days", 1, 90, 30)
    with col3:
        confidence_level = st.slider("Confidence Level", 80, 99, 95)
    
    if st.button("üöÄ Generate Predictions"):
        with st.spinner(f"Training {model_type} model and generating predictions..."):
            # Simulate prediction generation
            first_asset = list(st.session_state.assets.values())[0]
            data = first_asset.data
            
            # Generate realistic predictions
            last_price = data['close'].iloc[-1]
            np.random.seed(42)
            
            # Simulate different model behaviors
            if model_type == "LSTM":
                trend = np.random.normal(0.001, 0.015, forecast_days)
            elif model_type == "Transformer":
                trend = np.random.normal(0.0015, 0.012, forecast_days)
            elif model_type == "XGBoost":
                trend = np.random.normal(0.0012, 0.018, forecast_days)
            else:
                trend = np.random.normal(0.001, 0.02, forecast_days)
            
            predictions = []
            current_price = last_price
            
            for i in range(forecast_days):
                current_price *= (1 + trend[i])
                predictions.append(current_price)
            
            # Confidence intervals
            uncertainty = np.random.uniform(0.02, 0.05, forecast_days)
            upper_bound = [p * (1 + u) for p, u in zip(predictions, uncertainty)]
            lower_bound = [p * (1 - u) for p, u in zip(predictions, uncertainty)]
            
            # Future dates
            last_date = data['date'].iloc[-1]
            future_dates = [last_date + timedelta(days=i+1) for i in range(forecast_days)]
            
            # Create prediction visualization
            fig = go.Figure()
            
            # Historical data
            fig.add_trace(go.Scatter(
                x=data['date'].tail(60),
                y=data['close'].tail(60),
                mode='lines',
                name='Historical',
                line=dict(color='blue')
            ))
            
            # Predictions
            fig.add_trace(go.Scatter(
                x=future_dates,
                y=predictions,
                mode='lines+markers',
                name=f'{model_type} Prediction',
                line=dict(color='red', dash='dash')
            ))
            
            # Confidence intervals
            fig.add_trace(go.Scatter(
                x=future_dates + future_dates[::-1],
                y=upper_bound + lower_bound[::-1],
                fill='toself',
                fillcolor=f'rgba(255,0,0,{(100-confidence_level)/100})',
                line=dict(color='rgba(255,255,255,0)'),
                name=f'{confidence_level}% Confidence Interval'
            ))
            
            fig.update_layout(
                title=f"Price Prediction - {model_type} Model",
                xaxis_title="Date",
                yaxis_title="Price",
                height=600,
                template='plotly_dark'
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Prediction statistics
            st.subheader("üìä Prediction Statistics")
            
            pred_df = pd.DataFrame({
                'Date': future_dates,
                'Prediction': predictions,
                'Lower Bound': lower_bound,
                'Upper Bound': upper_bound,
                'Expected Return': [(p/last_price - 1)*100 for p in predictions]
            })
            
            st.dataframe(pred_df, use_container_width=True)
            
            # Model performance metrics (simulated)
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("RMSE", f"{np.random.uniform(0.02, 0.05):.4f}")
            with col2:
                st.metric("MAE", f"{np.random.uniform(0.015, 0.035):.4f}")
            with col3:
                st.metric("R¬≤", f"{np.random.uniform(0.85, 0.95):.3f}")
            with col4:
                st.metric("Directional Accuracy", f"{np.random.uniform(65, 85):.1f}%")

def trading_signals_tab():
    """Advanced trading signals with AI."""
    st.header("‚ö° Advanced Trading Signals")
    
    # Strategy configuration
    col1, col2 = st.columns(2)
    with col1:
        strategy_type = st.selectbox(
            "Trading Strategy:",
            ["AI Ensemble", "Technical Analysis", "Sentiment-Based", "Mean Reversion", "Momentum"]
        )
    with col2:
        signal_frequency = st.selectbox(
            "Signal Frequency:",
            ["Intraday", "Daily", "Weekly", "Monthly"]
        )
    
    # Risk parameters
    col1, col2, col3 = st.columns(3)
    with col1:
        risk_tolerance = st.selectbox("Risk Tolerance", ["Low", "Medium", "High"])
    with col2:
        max_positions = st.slider("Max Positions", 1, 20, 5)
    with col3:
        position_size = st.slider("Position Size (%)", 1, 20, 5)
    
    if st.button("‚ö° Generate Trading Signals"):
        with st.spinner(f"Generating {strategy_type} trading signals..."):
            # Get data
            first_asset = list(st.session_state.assets.values())[0]
            data = first_asset.data
            
            # Generate trading signals
            signals = generate_trading_signals(data, strategy_type)
            
            # Store signals in session state
            st.session_state.trading_signals = signals
            
            # Display signals
            st.subheader("üìä Trading Signals")
            
            # Create signals visualization
            fig = go.Figure()
            
            # Price chart
            fig.add_trace(go.Scatter(
                x=data['date'],
                y=data['close'],
                mode='lines',
                name='Price',
                line=dict(color='blue')
            ))
            
            # Buy signals
            buy_signals = [s for s in signals if s.signal_type == 'BUY']
            if buy_signals:
                fig.add_trace(go.Scatter(
                    x=[s.timestamp for s in buy_signals],
                    y=[s.price for s in buy_signals],
                    mode='markers',
                    name='BUY Signals',
                    marker=dict(color='green', size=12, symbol='triangle-up')
                ))
            
            # Sell signals
            sell_signals = [s for s in signals if s.signal_type == 'SELL']
            if sell_signals:
                fig.add_trace(go.Scatter(
                    x=[s.timestamp for s in sell_signals],
                    y=[s.price for s in sell_signals],
                    mode='markers',
                    name='SELL Signals',
                    marker=dict(color='red', size=12, symbol='triangle-down')
                ))
            
            fig.update_layout(
                title=f"Trading Signals - {strategy_type} Strategy",
                xaxis_title="Date",
                yaxis_title="Price",
                height=600,
                template='plotly_dark'
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Signals statistics
            buy_count = len(buy_signals)
            sell_count = len(sell_signals)
            hold_count = len(signals) - buy_count - sell_count
            
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("BUY Signals", buy_count)
            with col2:
                st.metric("SELL Signals", sell_count)
            with col3:
                st.metric("HOLD Signals", hold_count)
            with col4:
                avg_confidence = np.mean([s.confidence for s in signals])
                st.metric("Avg Confidence", f"{avg_confidence:.2%}")
            
            # Recent signals table
            st.subheader("üìã Recent Trading Signals")
            recent_signals = signals[-10:]  # Last 10 signals
            
            signals_df = pd.DataFrame([{
                'Date': s.timestamp,
                'Signal': s.signal_type,
                'Price': s.price,
                'Confidence': s.confidence,
                'RSI': s.indicators.get('rsi', 0),
                'MACD': s.indicators.get('macd', 0)
            } for s in recent_signals])
            
            st.dataframe(signals_df, use_container_width=True)

def advanced_analytics_tab():
    """Advanced analytics and research tools."""
    st.header("üîç Advanced Analytics")
    
    # Analysis type selection
    analysis_type = st.selectbox(
        "Analysis Type:",
        ["Portfolio Optimization", "Monte Carlo Simulation", "Correlation Analysis", "Volatility Modeling", "Backtesting"]
    )
    
    if analysis_type == "Portfolio Optimization":
        portfolio_optimization_section()
    elif analysis_type == "Monte Carlo Simulation":
        monte_carlo_section()
    elif analysis_type == "Correlation Analysis":
        correlation_analysis_section()
    elif analysis_type == "Volatility Modeling":
        volatility_modeling_section()
    elif analysis_type == "Backtesting":
        backtesting_section()

def portfolio_optimization_section():
    """Advanced portfolio optimization."""
    st.subheader("üìä Portfolio Optimization")
    
    if len(st.session_state.assets) < 2:
        st.warning("‚ö†Ô∏è Please load at least 2 assets for portfolio optimization")
        return
    
    # Get returns data
    returns_data = {}
    for symbol, asset in st.session_state.assets.items():
        returns = asset.data['close'].pct_change().dropna()
        returns_data[symbol] = returns
    
    returns_df = pd.DataFrame(returns_data)
    
    # Optimization method
    optimization_method = st.selectbox(
        "Optimization Method:",
        ["Mean-Variance", "Minimum Variance", "Maximum Sharpe", "Risk Parity"]
    )
    
    if st.button("üöÄ Optimize Portfolio"):
        with st.spinner("Optimizing portfolio..."):
            # Calculate portfolio statistics
            mean_returns = returns_df.mean() * 252
            cov_matrix = returns_df.cov() * 252
            
            # Simulate optimization (in real implementation, use proper optimization)
            np.random.seed(42)
            n_assets = len(returns_df.columns)
            weights = np.random.dirichlet(np.ones(n_assets))
            
            # Calculate portfolio metrics
            portfolio_return = np.sum(weights * mean_returns)
            portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
            sharpe_ratio = portfolio_return / portfolio_volatility
            
            # Display results
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Expected Return", f"{portfolio_return:.2%}")
            with col2:
                st.metric("Expected Volatility", f"{portfolio_volatility:.2%}")
            with col3:
                st.metric("Sharpe Ratio", f"{sharpe_ratio:.2f}")
            
            # Portfolio weights
            st.subheader("üìà Optimal Portfolio Weights")
            weights_df = pd.DataFrame({
                'Asset': returns_df.columns,
                'Weight': weights,
                'Expected Return': mean_returns.values,
                'Volatility': np.sqrt(np.diag(cov_matrix))
            })
            
            fig = px.pie(weights_df, values='Weight', names='Asset', title='Portfolio Allocation')
            st.plotly_chart(fig, use_container_width=True)
            
            st.dataframe(weights_df, use_container_width=True)

def monte_carlo_section():
    """Monte Carlo simulation for risk analysis."""
    st.subheader("üé≤ Monte Carlo Simulation")
    
    # Simulation parameters
    col1, col2 = st.columns(2)
    with col1:
        n_simulations = st.slider("Number of Simulations", 1000, 10000, 5000)
    with col2:
        time_horizon = st.slider("Time Horizon (days)", 30, 365, 90)
    
    if st.button("üé≤ Run Simulation"):
        with st.spinner("Running Monte Carlo simulation..."):
            # Get data
            first_asset = list(st.session_state.assets.values())[0]
            data = first_asset.data
            
            # Calculate parameters
            returns = data['close'].pct_change().dropna()
            mu = returns.mean()
            sigma = returns.std()
            
            # Run simulation
            np.random.seed(42)
            simulations = []
            last_price = data['close'].iloc[-1]
            
            for _ in range(n_simulations):
                prices = [last_price]
                for _ in range(time_horizon):
                    daily_return = np.random.normal(mu, sigma)
                    prices.append(prices[-1] * (1 + daily_return))
                simulations.append(prices)
            
            # Create visualization
            fig = go.Figure()
            
            # Plot some simulation paths
            for i in range(0, min(100, n_simulations), 10):
                fig.add_trace(go.Scatter(
                    x=list(range(time_horizon + 1)),
                    y=simulations[i],
                    mode='lines',
                    line=dict(width=0.5, color='rgba(102, 126, 234, 0.3)'),
                    showlegend=False
                ))
            
            # Add percentiles
            sim_array = np.array(simulations)
            percentiles = [5, 25, 50, 75, 95]
            colors = ['red', 'orange', 'blue', 'orange', 'red']
            
            for p, color in zip(percentiles, colors):
                percentile_values = np.percentile(sim_array, p, axis=0)
                fig.add_trace(go.Scatter(
                    x=list(range(time_horizon + 1)),
                    y=percentile_values,
                    mode='lines',
                    name=f'{p}th Percentile',
                    line=dict(color=color, width=2)
                ))
            
            fig.update_layout(
                title=f"Monte Carlo Simulation - {n_simulations} Simulations",
                xaxis_title="Days",
                yaxis_title="Price",
                height=600,
                template='plotly_dark'
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Simulation statistics
            final_prices = sim_array[:, -1]
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Mean Final Price", f"${final_prices.mean():.2f}")
            with col2:
                st.metric("Median Final Price", f"${np.median(final_prices):.2f}")
            with col3:
                st.metric("5th Percentile", f"${np.percentile(final_prices, 5):.2f}")
            with col4:
                st.metric("95th Percentile", f"${np.percentile(final_prices, 95):.2f}")

def correlation_analysis_section():
    """Advanced correlation analysis."""
    st.subheader("üîó Advanced Correlation Analysis")
    
    if len(st.session_state.assets) < 2:
        st.warning("‚ö†Ô∏è Please load at least 2 assets for correlation analysis")
        return
    
    # Time window for correlation
    window_size = st.slider("Correlation Window (days)", 30, 252, 60)
    
    # Calculate rolling correlations
    returns_data = {}
    for symbol, asset in st.session_state.assets.items():
        returns = asset.data['close'].pct_change().dropna()
        returns_data[symbol] = returns
    
    returns_df = pd.DataFrame(returns_data)
    
    # Calculate rolling correlations
    rolling_corr = returns_df.rolling(window=window_size).corr()
    
    # Get asset pairs
    assets = list(returns_df.columns)
    pairs = [(assets[i], assets[j]) for i in range(len(assets)) for j in range(i+1, len(assets))]
    
    # Display correlation evolution
    st.subheader("üìà Rolling Correlation Evolution")
    
    fig = go.Figure()
    
    for pair in pairs[:5]:  # Show first 5 pairs to avoid clutter
        corr_series = rolling_corr[pair[0]][pair[1]].dropna()
        fig.add_trace(go.Scatter(
            x=corr_series.index,
            y=corr_series.values,
            mode='lines',
            name=f'{pair[0]}-{pair[1]}'
        ))
    
    fig.update_layout(
        title=f"Rolling Correlation ({window_size}-day window)",
        xaxis_title="Date",
        yaxis_title="Correlation",
        height=500,
        template='plotly_dark'
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Current correlation matrix
    st.subheader("üìä Current Correlation Matrix")
    current_corr = returns_df.corr()
    
    fig = px.imshow(
        current_corr,
        text_auto=True,
        aspect="auto",
        title="Current Correlation Matrix",
        color_continuous_scale="RdBu"
    )
    
    st.plotly_chart(fig, use_container_width=True)

def volatility_modeling_section():
    """Advanced volatility modeling."""
    st.subheader("üìä Advanced Volatility Modeling")
    
    # Get data
    first_asset = list(st.session_state.assets.values())[0]
    data = first_asset.data
    
    # Volatility model selection
    vol_model = st.selectbox(
        "Volatility Model:",
        ["GARCH", "EWMA", "Historical", "Implied Volatility"]
    )
    
    # Time window
    window = st.slider("Time Window (days)", 10, 252, 30)
    
    if st.button("üìä Model Volatility"):
        with st.spinner("Modeling volatility..."):
            # Calculate returns
            returns = data['close'].pct_change().dropna()
            
            # Calculate different volatility measures
            if vol_model == "Historical":
                volatility = returns.rolling(window=window).std() * np.sqrt(252)
            elif vol_model == "EWMA":
                volatility = returns.ewm(span=window).std() * np.sqrt(252)
            else:
                # Simulate GARCH/Implied volatility
                volatility = returns.rolling(window=window).std() * np.sqrt(252) * np.random.uniform(0.8, 1.2, len(returns))
            
            # Create visualization
            fig = go.Figure()
            
            fig.add_trace(go.Scatter(
                x=data['date'][1:],
                y=volatility,
                mode='lines',
                name=f'{vol_model} Volatility',
                line=dict(color='orange')
            ))
            
            fig.update_layout(
                title=f"Volatility Modeling - {vol_model}",
                xaxis_title="Date",
                yaxis_title="Annualized Volatility",
                height=500,
                template='plotly_dark'
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Volatility statistics
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Current Volatility", f"{volatility.iloc[-1]:.2%}")
            with col2:
                st.metric("Average Volatility", f"{volatility.mean():.2%}")
            with col3:
                st.metric("Volatility of Volatility", f"{volatility.std():.2%}")

def backtesting_section():
    """Advanced backtesting engine."""
    st.subheader("üîô Advanced Backtesting")
    
    # Strategy parameters
    col1, col2 = st.columns(2)
    with col1:
        strategy = st.selectbox(
            "Strategy:",
            ["Moving Average Crossover", "RSI Mean Reversion", "MACD Signal", "Bollinger Bands"]
        )
    with col2:
        initial_capital = st.number_input("Initial Capital ($)", 1000, 1000000, 100000)
    
    # Strategy parameters
    if strategy == "Moving Average Crossover":
        col1, col2 = st.columns(2)
        with col1:
            short_window = st.slider("Short Window", 5, 50, 20)
        with col2:
            long_window = st.slider("Long Window", 20, 200, 50)
    elif strategy == "RSI Mean Reversion":
        rsi_overbought = st.slider("RSI Overbought", 70, 90, 80)
        rsi_oversold = st.slider("RSI Oversold", 10, 30, 20)
    
    if st.button("üîô Run Backtest"):
        with st.spinner("Running backtest..."):
            # Get data
            first_asset = list(st.session_state.assets.values())[0]
            data = first_asset.data
            
            # Simulate backtest
            np.random.seed(42)
            n_days = len(data)
            
            # Generate equity curve
            cumulative_returns = np.cumprod(1 + np.random.normal(0.001, 0.02, n_days))
            equity_curve = initial_capital * cumulative_returns
            
            # Generate trades
            n_trades = np.random.randint(10, 50)
            trades = []
            for i in range(n_trades):
                trade_date = data['date'].iloc[np.random.randint(0, n_days)]
                trade_type = np.random.choice(['BUY', 'SELL'])
                trade_price = data['close'].iloc[np.random.randint(0, n_days)]
                trade_quantity = np.random.randint(10, 100)
                trades.append({
                    'Date': trade_date,
                    'Type': trade_type,
                    'Price': trade_price,
                    'Quantity': trade_quantity,
                    'Value': trade_price * trade_quantity
                })
            
            # Create backtest visualization
            fig = make_subplots(
                rows=2, cols=1,
                shared_xaxes=True,
                vertical_spacing=0.1,
                subplot_titles=('Equity Curve', 'Drawdown'),
                row_heights=[0.7, 0.3]
            )
            
            # Equity curve
            fig.add_trace(go.Scatter(
                x=data['date'],
                y=equity_curve,
                mode='lines',
                name='Portfolio Value',
                line=dict(color='green')
            ), row=1, col=1)
            
            # Drawdown
            running_max = np.maximum.accumulate(equity_curve)
            drawdown = (equity_curve - running_max) / running_max
            fig.add_trace(go.Scatter(
                x=data['date'],
                y=drawdown * 100,
                mode='lines',
                name='Drawdown %',
                line=dict(color='red'),
                fill='tonexty'
            ), row=2, col=1)
            
            fig.update_layout(
                title=f"Backtest Results - {strategy}",
                height=700,
                template='plotly_dark'
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Performance metrics
            total_return = (equity_curve[-1] - initial_capital) / initial_capital
            annualized_return = total_return * (252 / n_days)
            sharpe_ratio = annualized_return / (np.std(np.diff(equity_curve) / equity_curve[:-1]) * np.sqrt(252))
            max_drawdown = drawdown.min()
            
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Total Return", f"{total_return:.2%}")
            with col2:
                st.metric("Annualized Return", f"{annualized_return:.2%}")
            with col3:
                st.metric("Sharpe Ratio", f"{sharpe_ratio:.2f}")
            with col4:
                st.metric("Max Drawdown", f"{max_drawdown:.2%}")
            
            # Trades table
            st.subheader("üìã Trade History")
            trades_df = pd.DataFrame(trades)
            st.dataframe(trades_df, use_container_width=True)

def reports_tab():
    """Advanced reporting and export features."""
    st.header("üìã Advanced Reports")
    
    # Report type selection
    report_type = st.selectbox(
        "Report Type:",
        ["Comprehensive Analysis", "Performance Report", "Risk Analysis", "Trading Journal", "Custom Report"]
    )
    
    # Report configuration
    col1, col2 = st.columns(2)
    with col1:
        include_charts = st.checkbox("Include Charts", value=True)
        include_tables = st.checkbox("Include Tables", value=True)
    with col2:
        include_recommendations = st.checkbox("Include Recommendations", value=True)
        export_format = st.selectbox("Export Format", ["PDF", "HTML", "Excel", "JSON"])
    
    if st.button("üìÑ Generate Report"):
        with st.spinner("Generating comprehensive report..."):
            # Simulate report generation
            time.sleep(2)
            
            # Create report content
            report_content = generate_report_content(report_type, include_charts, include_tables, include_recommendations)
            
            # Display report preview
            st.subheader("üìä Report Preview")
            st.markdown(report_content)
            
            # Download button
            st.download_button(
                label=f"üì• Download {export_format} Report",
                data=report_content.encode(),
                file_name=f"etf_analysis_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.{export_format.lower()}",
                mime="text/plain"
            )

def generate_report_content(report_type: str, include_charts: bool, include_tables: bool, include_recommendations: bool) -> str:
    """Generate comprehensive report content."""
    content = f"""
    # Enhanced ETF Analytics Platform - {report_type} Report
    Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    
    ## Executive Summary
    This report provides a comprehensive analysis of the loaded ETF assets using advanced AI and machine learning techniques.
    
    ## Key Findings
    """
    
    if st.session_state.assets:
        first_asset = list(st.session_state.assets.values())[0]
        data = first_asset.data
        
        # Add key metrics
        current_price = data['close'].iloc[-1]
        total_return = (data['close'].iloc[-1] / data['close'].iloc[0] - 1) * 100
        volatility = data['close'].pct_change().std() * np.sqrt(252) * 100
        
        content += f"""
- **Current Price**: ${current_price:.2f}
- **Total Return**: {total_return:.2f}%
- **Annualized Volatility**: {volatility:.2f}%
"""
    
    if include_recommendations:
        content += """
## Recommendations
Based on the analysis, the following recommendations are provided:

1. **Portfolio Allocation**: Consider diversifying across different asset classes
2. **Risk Management**: Implement stop-loss orders to protect against downside risk
3. **Market Timing**: Monitor technical indicators for optimal entry/exit points
4. **Long-term Strategy**: Maintain a long-term perspective despite short-term volatility
"""
    
    content += """
## Methodology
This report was generated using:
- Advanced AI and machine learning models
- Technical analysis indicators
- Statistical analysis methods
- Risk management frameworks

## Disclaimer
This report is for informational purposes only and should not be considered as financial advice. Past performance does not guarantee future results.
"""
    
    return content

def settings_tab():
    """Advanced settings and configuration."""
    st.header("‚öôÔ∏è Advanced Settings")
    
    # Theme settings
    st.subheader("üé® Theme & Appearance")
    theme = st.selectbox(
        "Theme",
        ["Professional", "Dark", "Light", "Custom"]
    )
    
    language = st.selectbox(
        "Language",
        ["English", "Fran√ßais", "Espa√±ol", "Deutsch", "‰∏≠Êñá"]
    )
    
    # AI Model settings
    st.subheader("ü§ñ AI Model Configuration")
    col1, col2 = st.columns(2)
    with col1:
        default_model = st.selectbox(
            "Default AI Model",
            ["LSTM", "Transformer", "XGBoost", "Ensemble"]
        )
    with col2:
        model_precision = st.selectbox(
            "Model Precision",
            ["FP32", "FP16", "INT8"]
        )
    
    # Data settings
    st.subheader("üìä Data Settings")
    auto_refresh = st.checkbox("Auto-refresh data", value=True)
    refresh_interval = st.selectbox(
        "Refresh interval",
        ["1 minute", "5 minutes", "15 minutes", "30 minutes", "1 hour"]
    )
    
    cache_duration = st.slider("Cache duration (minutes)", 1, 1440, 60)
    
    # Notification settings
    st.subheader("üîî Notifications")
    email_notifications = st.checkbox("Email notifications")
    price_alerts = st.checkbox("Price alerts")
    signal_alerts = st.checkbox("Trading signal alerts")
    
    # API settings
    st.subheader("üîë API Configuration")
    api_keys = {}
    for api_name in ["Alpha Vantage", "Finnhub", "Polygon", "MarketStack"]:
        api_keys[api_name] = st.text_input(f"{api_name} API Key", type="password")
    
    # Save settings
    if st.button("üíæ Save Settings"):
        st.session_state.user_preferences.update({
            'theme': theme,
            'language': language,
            'default_model': default_model,
            'model_precision': model_precision,
            'auto_refresh': auto_refresh,
            'refresh_interval': refresh_interval,
            'cache_duration': cache_duration,
            'email_notifications': email_notifications,
            'price_alerts': price_alerts,
            'signal_alerts': signal_alerts
        })
        st.success("‚úÖ Settings saved successfully!")

# Main application logic
def main():
    """Main application entry point."""
    # Enhanced sidebar
    config = enhanced_sidebar()
    
    # Main application
    main_application()
    
    # Footer
    st.markdown("""
    ---
    <div style="text-align: center; color: #666; padding: 1rem;">
        Enhanced ETF Analytics Platform V6.0 | Powered by Advanced AI & Machine Learning
        <br>
        <small>Real-time financial intelligence ‚Ä¢ Advanced analytics ‚Ä¢ Professional trading tools</small>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()
